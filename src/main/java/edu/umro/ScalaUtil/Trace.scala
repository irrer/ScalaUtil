/*
 * Copyright 2021 Regents of the University of Michigan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edu.umro.ScalaUtil

import java.awt.Desktop
import java.awt.Dimension
import java.awt.Graphics
import java.awt.image.BufferedImage
import java.io.File
import java.net.URI
import java.text.SimpleDateFormat
import java.util.Date
import java.util.concurrent.CountDownLatch
import javax.imageio.ImageIO
import javax.swing.JFrame
import javax.swing.JPanel
import javax.swing.WindowConstants

/**
  * For debugging code.  Print source line and optionally, parameters.
  */
object Trace {

  private val dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")

  /** Time of last trace message. */
  private var time = System.currentTimeMillis

  /** If true, do tracing.  If false, do not trace.  Default is true. */
  private var active = true

  /**
    * Turn tracing on.
    */
  def on(): Unit = {
    active = true
  }

  /**
    * Turn tracing off.
    */
  //noinspection ScalaUnusedSymbol
  def off(): Unit = {
    active = false
  }

  /**
    * Determine if tracing is on.
    *
    * @return True if tracing is on.
    */
  //noinspection ScalaUnusedSymbol
  def isOn: Boolean = active

  private def current: String = {
    val se = Thread.currentThread.getStackTrace()(3)
    // val line = se.getLineNumber
    // val method = se.getMethodName
    // val threadName = Thread.currentThread.getName
    val now = System.currentTimeMillis
    val elapsedText = {
      val e = (now - time) / 1000.0
      "%6.3f".format(e)
    }
    time = now
    // sometimes the thread is useful, but mostly it is just noise
    //"Trace " + dateFormat.format(new Date(now)) + " | " + threadName + " | " + elapsedText + " | " + se.toString
    "Trace " + dateFormat.format(new Date(now)) + " | " + elapsedText + " | " + se.toString
  }

  /** Print current line with time elapsed since last trace. */
  def trace(): Unit = {
    if (active)
      println(current)
  }

  /** Print current line and parameter value with time elapsed since last trace. */
  def trace(v: Any): Unit = {
    if (active) {
      val text = if (v == null) "null" else v.toString.replaceAll("\0", " ")
      println(current + " : " + text)
    }
  }

  /** Provide an id for each timing so that the start and finish can be matched up in a log file. */
  private var timeId = 0

  /**
    * Get a unique id to reference a statement being timed.
    * @return A unique ID.
    */
  private def getTimeId: Int =
    timeId.synchronized {
      timeId = timeId + 1
      timeId
    }

  /**
    * Provide timing and tracing information for a given statement.
    *
    * @param arg0 The statement to be evaluated
    * @tparam T0 Type of value that statement returns.
    * @return The value generated by the statement.
    */
  def time[T0](arg0: => T0): T0 = {
    val id = getTimeId
    println(current + " starting " + id)
    val start = System.currentTimeMillis()
    val value = arg0
    val elapsed = System.currentTimeMillis() - start
    println(current + " finished " + id + "   Elapsed ms: " + elapsed)
    value
  }

  /**
    * Given an image, display it to the user in a new window.  Do not return until the user closes the window.
    * @param img Show this image.
    */
  //noinspection ScalaUnusedSymbol
  def showImageAndWait(img: BufferedImage): Unit = {
    val latch = new CountDownLatch(1)

    // Create a JPanel that paints the image
    val panel = new JPanel() {
      override def paintComponent(g: Graphics): Unit = {
        super.paintComponent(g)
        g.drawImage(img, 0, 0, this)
      }

      override def getPreferredSize: Dimension =
        new Dimension(img.getWidth, img.getHeight)
    }

    // Create and set up the window
    val frame = new JFrame("Image Viewer")
    frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)
    frame.add(panel)
    frame.pack()
    frame.setLocationRelativeTo(null) // Center on screen
    frame.setVisible(true)

    // Add a window listener to release the latch when closed
    frame.addWindowListener(new java.awt.event.WindowAdapter {
      override def windowClosed(e: java.awt.event.WindowEvent): Unit = {
        latch.countDown()
      }
    })

    // Wait until window is closed
    latch.await()
  }

  /**
    * Show the given image using MS Paint.  Image is first written to a temporary file which
    * is deleted when the calling program exits.
    *
    * @param img Image to be shown.
    */
  //noinspection ScalaUnusedSymbol
  //noinspection ScalaWeakerAccess
  def showInMSPaint(img: BufferedImage): Unit = {
    // Save the image to a temporary PNG file
    val tempFile = File.createTempFile("tempImage", ".png")
    tempFile.deleteOnExit()
    ImageIO.write(img, "png", tempFile)

    // Command to open MS Paint with the temp file
    //noinspection SpellCheckingInspection
    val paintCmd = Array("mspaint", tempFile.getAbsolutePath)
    // Start the process
    val process = new ProcessBuilder(paintCmd: _*).start()
    // Optionally wait for Paint to open (not necessary here)
  }

  /**
    * Create a chart in a temporary file and display it with a browser.
    *
    * Note that you must wait for the page to be displayed before terminating the program.
    * @param data List of data points.
    * @param name Name of chart, defaults to "Line Chart"
    */
  //noinspection ScalaUnusedSymbol
  def showChart(data: Seq[Double], name: String = "Line Chart", xName: String = "X"): Unit = {

    val xText = data.indices.mkString(",")
    val yText = data.mkString(",")

    //noinspection SpellCheckingInspection
    val htmlText =
      s"""
         |<!DOCTYPE html>
         |<html lang="en">
         |<head>
         |    <meta charset="UTF-8">
         |    <title>C3.js Line Chart Example</title>
         |    <!-- C3.css -->
         |    <link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.css" rel="stylesheet">
         |    <style>
         |        body {
         |            font-family: Arial, sans-serif;
         |            margin: 2em;
         |        }
         |        #chart {
         |            max-width: 800px;
         |            margin: auto;
         |        }
         |    </style>
         |</head>
         |<body>
         |    <h2>$name</h2>
         |    <div id="chart"></div>
         |
         |    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
         |    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.js"></script>
         |    <script>
         |        // Generate 100 simple random data points
         |        // Example: y-values are random, x-values are 1 to 100
         |        var xData = [$xText],
         |            yData = ['$xName', $yText];
         |        var chart = c3.generate({
         |            bindto: '#chart',
         |            data: {
         |                x: 'x',
         |                columns: [
         |                    ['x'].concat(xData),
         |                    yData
         |                ],
         |                type: 'line'
         |            },
         |            axis: {
         |                x: {
         |                    label: 'X Value',
         |                    tick: {
         |                        count: 10
         |                    }
         |                },
         |                y: {
         |                    label: 'Y Value'
         |                }
         |            }
         |        });
         |    </script>
         |</body>
         |</html>
         |
         |""".stripMargin

    val tempFile = File.createTempFile("tempChart", ".html")
    tempFile.deleteOnExit()
    edu.umro.ScalaUtil.FileUtil.writeFile(tempFile, htmlText)

    val fileUri: URI = tempFile.toURI
    Desktop.getDesktop.browse(fileUri)
  }

  /** For testing only. */
  def main(args: Array[String]): Unit = {
    trace("hey E")
    Thread.sleep(100)
    trace()

    def doMany(delay: Long): Long = {
      Thread.sleep(delay)
      System.currentTimeMillis()
    }

    for (_ <- 0 until 5) {
      val result = time(doMany(20))
      println("result: " + result)
    }
  }

}
